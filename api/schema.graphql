type Query {
    userLeagues(userId: ID!): [League!]!
    # TODO: do other User queries need to go here for auth or anything else?
    league(leagueId: ID!): League!
    leaguePointSettings(leagueId: ID!): [LeaguePointSetting!]!
    roundPointSettings(roundId: ID!): [RoundPointSetting!]!
    scheduledRounds(leagueId: ID!): [Round!]!
    completedRounds(leagueId: ID!): [Round!]!
    player(playerId: ID!): LeaguePlayer!
    playerRound(playerId: ID!): [PlayerRound!]!
    playerPointsEarned(playerId: ID!, roundId: ID): [PointEarned!]
    playerScoreForHole(playerId: ID!, holeId: ID): PlayerHole!
    playerScoresForRound(playerId: ID!, roundId: ID): [PlayerHole!]!
}
 
type Mutation {
    # TODO: For all of these that currently takes an ID as the first arg - When should ID be it's own argument as opposed to being part of the data: input??
    # User 
    createUser(data: CreateUserInput!): AuthPayload!
    loginUser(email: String!, password: String!): AuthPayload!
    updateUser(data: UpdateUserInput!): User!
    # League  (must be authorizedAsAdmin to change league settings)
    createLeague(data: CreateLeagueInput!) League!
    deleteLeague(leagueId: ID!)
    updateBasicLeagueInfo(leagueId: ID!, data: UpdateBasicLeagueInput): League!
    createLeaguePointSetting(leagueId: ID!, data: CreateLeaguePointSettingInput): LeaguePointSetting!
    updateLeaguePointSetting(leagueId: ID!, data: UpdateLeaguePointSettingInput): LeaguePointSetting!
    deleteLeaguePointSetting(leagueId: ID!)
    createRoundPointSetting(roundId: ID! data: CreateRoundPointSettingInput): RoundPointSetting!
    updateRoundPointSetting(roundId: ID! data: UpdateRoundPointSettingInput): RoundPointSetting!
    deleteRoundPointSetting(roundId: ID!)
    createLeaguePlayer(playerId: ID!, data: CreateLeaguePlayerInput): LeaguePlayer!
    updateLeaguePlayer(playerId: ID!, data: UpdateLeaguePlayerInput): LeaguePlayer!
    deleteLeaguePlayer(playerId: ID!)
    createRound(leagueId: ID!, data: createRoundInput): Round!
    updateRound(roundId: ID!, data: updateRoundInput): Round!
    deleteRound(leagueId: ID!)
    addPlayerToRound(roundId: ID!, playerId: ID!, data: addPlayerToRoundInput): Round!
    updatePlayerRound(roundId: ID!, playerId: ID!, data: updatePlayerRoundInput): Round!
    deletePlayerFromRound(roundId: ID!, playerId: ID!)
    # TODO: is leagueID necessary? Should I be returning Player?
    addPlayerPoints(playerId: ID!, roundId: ID!, leagueID: ID! weightMultiplier: Float): LeaguePlayer!
    updatePlayerPoints(playerId: ID!, roundId: ID!, leagueID: ID! weightMultiplier: Float): PlayerHole!
    deletePlayerPoints(playerId: ID!, roundId: ID!): [PlayerHole!]!

    # TODO: Implement these Comment mutations after MVP
    # createRoundComment(data: CreatePostInput!): Post!
    # deleteRoundComment(id: ID!): Post!
    # updateRoundComment(id: ID!, data: UpdatePostInput!): Post!
    # createLeagueComment(data: CreateCommentInput!): Comment!
    # deleteLeagueComment(id: ID!): Comment!
    # updateLeagueComment(id: ID!, data: UpdateCommentInput!): Comment!
}
input CreateUserInput {
    firstName: String!
    lastName: String!
    email: String!
    password: String!
}
input UpdateUserInput {
    firstName: String
    lastName: String
    email: String
    password: String
}
input CreateLeagueInput {
    name: String!
    startDate: DateTime
    endDate: DateTime
}
input UpdateBasicLeagueInput {
    name: String
    startDate: DateTime
    endDate: DateTime
}
input CreateLeaguePointSettingInput {
    name: String!
    weight: Float!
    default: Boolean!
}
input UpdateLeaguePointSettingInput {
    name: String
    weight: Float
    default: Boolean
}
input CreateRoundPointSettingInput {
    name: String!
    weight: Float!
}
input UpdateRoundPointSettingInput {
    name: String
    weight: Float
}
input CreateLeaguePlayerInput {
    customName: String!
    handicap: Float
    authorizedForAdmin: Boolean!
}
input UpdateLeaguePlayerInput {
    customName: String
    handicap: Float
    authorizedForAdmin: Boolean
}
input createRoundInput {
    golfCourse: String!
    holesPlayed: Int
    date: DateTime!
    name: String!
    completed: Boolean!
}
input updateRoundInput {
    golfCourse: String
    holesPlayed: Int
    date: DateTime
    name: String
    completed: Boolean
}
input addPlayerToRoundInput {
    handicap: Float
    holesPlayed: Int
    roundScore: Int
}
input updatePlayerRoundInput {
    handicap: Float
    holesPlayed: Int
    roundScore: Int
}
# TODO: Not very sure about this
input addPlayerPointInput {
    weightMultiplier: Int!
}

type User {
    id: ID!
    username: String!
    lastName: String!
    firstName: String!
    email: String!
    password: String!
    leagues: [League!]!
}

type League {
    id: ID!
    name: String!
    startDate: DateTime
    endDate: DateTime
    players: [LeaguePlayer!]!
    prizes: [LeaguePrize!]!
    # determines if league shows up on User's dashboard
    archived: Boolean!
}

type LeaguePrize {
    id: ID!
    league: League!
    description: String!
    prize: String!
}

type LeaguePlayer {
    id: ID!
    user: User!
    leagueId: League!
    customName: String
    # This field is initially set by the user that sets up the league
    authorizedForAdmin: Boolean!
    rounds: [Round!]!
    handicap: Float
}

type Round {
    id: ID!
    golfCourse: String!
    holesPlayed: Int
    date: DateTime!
    players: [Player!]!
    name: String
    # TODO: should I keep this completed field??
    completed: Boolean
    pointSettings: [RoundPointSetting!]!
    playerScoresByHole: [PlayerHole!]!
}

# TODO: Is this type even necessary or is it redundant since points can be calculated from PointEarned?
type PlayerRound {
    # TODO: is an id: ID! field needed here?
    id: ID!
    round: Round!
    points: [PointEarned!]!
    # TODO: How are these 2 fields affect things if players are recording hole-by-hole scores
    holesPlayed: Int
    roundScores: [PlayerHole!]! 
    # This field will be set to whatever the player's league-level handicap is on the day of the round 
    handicap: Float
    # TODO: link to PlayerHole?
}

type LeaguePointSetting {
    id: ID!
    league: League!
    name: String!
    weight: Float!
    defaultRoundPoint: Boolean!
}

type RoundPointSetting {
    # TODO: is an id: ID! field needed here?
    id: ID!
    round: Round!
    name: String!
    weight: Float!
}

# TODO: Am I going about this correctly?
type PointEarned {
    # TODO: is an id: ID! field needed here?
    id: ID!
    pointId: RoundPointSetting!
    league: League!
    round: Round!
    player: Player!
    # TODO: is weightMultiplier field the best approach if I'm tracking a tally of each type of point earned by each player in each round?
    weightMultiplier: Int!
}

# For optional tracking players' hole-by-hole scores 
type PlayerHole {
    # TODO: is an id: ID! field needed here?
    id: ID!
    round: Round!
    player: LeaguePlayer!
    hole: Int!
    grossScore: Int!
    # TODO: how to make this non-nullable if they're tracking handicaps?
    netScore: Int
}

# TODO: Implement these comment types after MVP
# type Comment {
#     id: ID!
#     text: String!
#     author: User!
#     post: Post!
# }
# input CreateCommentInput {
#     text: String!
#     post: ID!
# }
# input UpdateCommentInput {
#     text: String
# }


